// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: afcon.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// League Request/Response
public struct Afcon_LeagueRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var leagueID: Int32 = 0

  public var season: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Afcon_LeagueResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var league: Afcon_League {
    get {return _league ?? Afcon_League()}
    set {_league = newValue}
  }
  /// Returns true if `league` has been explicitly set.
  public var hasLeague: Bool {return self._league != nil}
  /// Clears the value of `league`. Subsequent reads from it will return its default value.
  public mutating func clearLeague() {self._league = nil}

  public var country: Afcon_Country {
    get {return _country ?? Afcon_Country()}
    set {_country = newValue}
  }
  /// Returns true if `country` has been explicitly set.
  public var hasCountry: Bool {return self._country != nil}
  /// Clears the value of `country`. Subsequent reads from it will return its default value.
  public mutating func clearCountry() {self._country = nil}

  public var seasons: [Afcon_Season] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _league: Afcon_League? = nil
  fileprivate var _country: Afcon_Country? = nil
}

public struct Afcon_League: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int32 = 0

  public var name: String = String()

  public var type: String = String()

  public var logo: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Afcon_Country: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var code: String = String()

  public var flag: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Afcon_Season: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var year: Int32 = 0

  public var start: String = String()

  public var end: String = String()

  public var current: Bool = false

  public var coverage: Afcon_Coverage {
    get {return _coverage ?? Afcon_Coverage()}
    set {_coverage = newValue}
  }
  /// Returns true if `coverage` has been explicitly set.
  public var hasCoverage: Bool {return self._coverage != nil}
  /// Clears the value of `coverage`. Subsequent reads from it will return its default value.
  public mutating func clearCoverage() {self._coverage = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _coverage: Afcon_Coverage? = nil
}

public struct Afcon_Coverage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var fixtures: Afcon_FixtureCoverage {
    get {return _fixtures ?? Afcon_FixtureCoverage()}
    set {_fixtures = newValue}
  }
  /// Returns true if `fixtures` has been explicitly set.
  public var hasFixtures: Bool {return self._fixtures != nil}
  /// Clears the value of `fixtures`. Subsequent reads from it will return its default value.
  public mutating func clearFixtures() {self._fixtures = nil}

  public var standings: Bool = false

  public var players: Bool = false

  public var topScorers: Bool = false

  public var topAssists: Bool = false

  public var topCards: Bool = false

  public var injuries: Bool = false

  public var predictions: Bool = false

  public var odds: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _fixtures: Afcon_FixtureCoverage? = nil
}

public struct Afcon_FixtureCoverage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var events: Bool = false

  public var lineups: Bool = false

  public var statisticsFixtures: Bool = false

  public var statisticsPlayers: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Teams Request/Response
public struct Afcon_TeamsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var leagueID: Int32 = 0

  public var season: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Afcon_TeamsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var teams: [Afcon_TeamInfo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Afcon_TeamInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var team: Afcon_Team {
    get {return _team ?? Afcon_Team()}
    set {_team = newValue}
  }
  /// Returns true if `team` has been explicitly set.
  public var hasTeam: Bool {return self._team != nil}
  /// Clears the value of `team`. Subsequent reads from it will return its default value.
  public mutating func clearTeam() {self._team = nil}

  public var venue: Afcon_Venue {
    get {return _venue ?? Afcon_Venue()}
    set {_venue = newValue}
  }
  /// Returns true if `venue` has been explicitly set.
  public var hasVenue: Bool {return self._venue != nil}
  /// Clears the value of `venue`. Subsequent reads from it will return its default value.
  public mutating func clearVenue() {self._venue = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _team: Afcon_Team? = nil
  fileprivate var _venue: Afcon_Venue? = nil
}

public struct Afcon_Team: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int32 = 0

  public var name: String = String()

  public var code: String = String()

  public var country: String = String()

  public var founded: Int32 = 0

  public var national: Bool = false

  public var logo: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Afcon_Venue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int32 = 0

  public var name: String = String()

  public var address: String = String()

  public var city: String = String()

  public var capacity: Int32 = 0

  public var surface: String = String()

  public var image: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Fixtures Request/Response
public struct Afcon_FixturesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var leagueID: Int32 = 0

  public var season: Int32 = 0

  /// Optional: YYYY-MM-DD format
  public var date: String = String()

  /// Optional: filter by team
  public var teamID: Int32 = 0

  /// Optional: get only live matches
  public var live: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Afcon_FixturesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var fixtures: [Afcon_Fixture] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Today's Upcoming Fixtures Request
public struct Afcon_TodayUpcomingRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var leagueID: Int32 = 0

  public var season: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Get Fixture By ID Request
public struct Afcon_FixtureByIdRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var fixtureID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Single Fixture Response
public struct Afcon_FixtureResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var fixture: Afcon_Fixture {
    get {return _fixture ?? Afcon_Fixture()}
    set {_fixture = newValue}
  }
  /// Returns true if `fixture` has been explicitly set.
  public var hasFixture: Bool {return self._fixture != nil}
  /// Clears the value of `fixture`. Subsequent reads from it will return its default value.
  public mutating func clearFixture() {self._fixture = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _fixture: Afcon_Fixture? = nil
}

/// Get Fixture Events Request
public struct Afcon_FixtureEventsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var fixtureID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Fixture Event (goal, card, substitution, etc.)
public struct Afcon_FixtureEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var time: Afcon_EventTime {
    get {return _time ?? Afcon_EventTime()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {self._time = nil}

  public var team: Afcon_EventTeam {
    get {return _team ?? Afcon_EventTeam()}
    set {_team = newValue}
  }
  /// Returns true if `team` has been explicitly set.
  public var hasTeam: Bool {return self._team != nil}
  /// Clears the value of `team`. Subsequent reads from it will return its default value.
  public mutating func clearTeam() {self._team = nil}

  public var player: Afcon_EventPlayer {
    get {return _player ?? Afcon_EventPlayer()}
    set {_player = newValue}
  }
  /// Returns true if `player` has been explicitly set.
  public var hasPlayer: Bool {return self._player != nil}
  /// Clears the value of `player`. Subsequent reads from it will return its default value.
  public mutating func clearPlayer() {self._player = nil}

  public var assist: Afcon_EventPlayer {
    get {return _assist ?? Afcon_EventPlayer()}
    set {_assist = newValue}
  }
  /// Returns true if `assist` has been explicitly set.
  public var hasAssist: Bool {return self._assist != nil}
  /// Clears the value of `assist`. Subsequent reads from it will return its default value.
  public mutating func clearAssist() {self._assist = nil}

  /// "Goal", "Card", "subst", "Var"
  public var type: String = String()

  /// "Normal Goal", "Yellow Card", etc.
  public var detail: String = String()

  /// Optional comments
  public var comments: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _time: Afcon_EventTime? = nil
  fileprivate var _team: Afcon_EventTeam? = nil
  fileprivate var _player: Afcon_EventPlayer? = nil
  fileprivate var _assist: Afcon_EventPlayer? = nil
}

public struct Afcon_EventTime: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var elapsed: Int32 = 0

  public var extra: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Afcon_EventTeam: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int32 = 0

  public var name: String = String()

  public var logo: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Afcon_EventPlayer: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int32 = 0

  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Fixture Events Response
public struct Afcon_FixtureEventsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var events: [Afcon_FixtureEvent] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Get Fixtures By Date Request
public struct Afcon_FixturesByDateRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// YYYY-MM-DD format
  public var date: String = String()

  /// Optional: filter by league
  public var leagueID: Int32 = 0

  /// Optional: required if league_id is set
  public var season: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Get Next Upcoming Fixtures Request
public struct Afcon_NextUpcomingRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var leagueID: Int32 = 0

  public var season: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Afcon_Fixture: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int32 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var referee: String {
    get {return _storage._referee}
    set {_uniqueStorage()._referee = newValue}
  }

  public var timezone: String {
    get {return _storage._timezone}
    set {_uniqueStorage()._timezone = newValue}
  }

  public var date: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._date ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  public var hasDate: Bool {return _storage._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  public mutating func clearDate() {_uniqueStorage()._date = nil}

  public var timestamp: Int32 {
    get {return _storage._timestamp}
    set {_uniqueStorage()._timestamp = newValue}
  }

  public var periods: Afcon_FixturePeriods {
    get {return _storage._periods ?? Afcon_FixturePeriods()}
    set {_uniqueStorage()._periods = newValue}
  }
  /// Returns true if `periods` has been explicitly set.
  public var hasPeriods: Bool {return _storage._periods != nil}
  /// Clears the value of `periods`. Subsequent reads from it will return its default value.
  public mutating func clearPeriods() {_uniqueStorage()._periods = nil}

  public var venue: Afcon_FixtureVenue {
    get {return _storage._venue ?? Afcon_FixtureVenue()}
    set {_uniqueStorage()._venue = newValue}
  }
  /// Returns true if `venue` has been explicitly set.
  public var hasVenue: Bool {return _storage._venue != nil}
  /// Clears the value of `venue`. Subsequent reads from it will return its default value.
  public mutating func clearVenue() {_uniqueStorage()._venue = nil}

  public var status: Afcon_FixtureStatus {
    get {return _storage._status ?? Afcon_FixtureStatus()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {_uniqueStorage()._status = nil}

  public var teams: Afcon_FixtureTeams {
    get {return _storage._teams ?? Afcon_FixtureTeams()}
    set {_uniqueStorage()._teams = newValue}
  }
  /// Returns true if `teams` has been explicitly set.
  public var hasTeams: Bool {return _storage._teams != nil}
  /// Clears the value of `teams`. Subsequent reads from it will return its default value.
  public mutating func clearTeams() {_uniqueStorage()._teams = nil}

  public var goals: Afcon_FixtureGoals {
    get {return _storage._goals ?? Afcon_FixtureGoals()}
    set {_uniqueStorage()._goals = newValue}
  }
  /// Returns true if `goals` has been explicitly set.
  public var hasGoals: Bool {return _storage._goals != nil}
  /// Clears the value of `goals`. Subsequent reads from it will return its default value.
  public mutating func clearGoals() {_uniqueStorage()._goals = nil}

  public var score: Afcon_FixtureScore {
    get {return _storage._score ?? Afcon_FixtureScore()}
    set {_uniqueStorage()._score = newValue}
  }
  /// Returns true if `score` has been explicitly set.
  public var hasScore: Bool {return _storage._score != nil}
  /// Clears the value of `score`. Subsequent reads from it will return its default value.
  public mutating func clearScore() {_uniqueStorage()._score = nil}

  public var league: Afcon_FixtureLeague {
    get {return _storage._league ?? Afcon_FixtureLeague()}
    set {_uniqueStorage()._league = newValue}
  }
  /// Returns true if `league` has been explicitly set.
  public var hasLeague: Bool {return _storage._league != nil}
  /// Clears the value of `league`. Subsequent reads from it will return its default value.
  public mutating func clearLeague() {_uniqueStorage()._league = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Afcon_FixtureLeague: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int32 = 0

  public var name: String = String()

  public var season: Int32 = 0

  public var round: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Afcon_FixturePeriods: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var first: Int32 = 0

  public var second: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Afcon_FixtureVenue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int32 = 0

  public var name: String = String()

  public var city: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Afcon_FixtureStatus: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var long: String = String()

  public var short: String = String()

  public var elapsed: Int32 = 0

  public var extra: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Afcon_FixtureTeams: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var home: Afcon_FixtureTeam {
    get {return _home ?? Afcon_FixtureTeam()}
    set {_home = newValue}
  }
  /// Returns true if `home` has been explicitly set.
  public var hasHome: Bool {return self._home != nil}
  /// Clears the value of `home`. Subsequent reads from it will return its default value.
  public mutating func clearHome() {self._home = nil}

  public var away: Afcon_FixtureTeam {
    get {return _away ?? Afcon_FixtureTeam()}
    set {_away = newValue}
  }
  /// Returns true if `away` has been explicitly set.
  public var hasAway: Bool {return self._away != nil}
  /// Clears the value of `away`. Subsequent reads from it will return its default value.
  public mutating func clearAway() {self._away = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _home: Afcon_FixtureTeam? = nil
  fileprivate var _away: Afcon_FixtureTeam? = nil
}

public struct Afcon_FixtureTeam: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int32 = 0

  public var name: String = String()

  public var logo: String = String()

  public var winner: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Afcon_FixtureGoals: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var home: Int32 = 0

  public var away: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Afcon_FixtureScore: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var halftime: Afcon_ScoreDetail {
    get {return _halftime ?? Afcon_ScoreDetail()}
    set {_halftime = newValue}
  }
  /// Returns true if `halftime` has been explicitly set.
  public var hasHalftime: Bool {return self._halftime != nil}
  /// Clears the value of `halftime`. Subsequent reads from it will return its default value.
  public mutating func clearHalftime() {self._halftime = nil}

  public var fulltime: Afcon_ScoreDetail {
    get {return _fulltime ?? Afcon_ScoreDetail()}
    set {_fulltime = newValue}
  }
  /// Returns true if `fulltime` has been explicitly set.
  public var hasFulltime: Bool {return self._fulltime != nil}
  /// Clears the value of `fulltime`. Subsequent reads from it will return its default value.
  public mutating func clearFulltime() {self._fulltime = nil}

  public var extratime: Afcon_ScoreDetail {
    get {return _extratime ?? Afcon_ScoreDetail()}
    set {_extratime = newValue}
  }
  /// Returns true if `extratime` has been explicitly set.
  public var hasExtratime: Bool {return self._extratime != nil}
  /// Clears the value of `extratime`. Subsequent reads from it will return its default value.
  public mutating func clearExtratime() {self._extratime = nil}

  public var penalty: Afcon_ScoreDetail {
    get {return _penalty ?? Afcon_ScoreDetail()}
    set {_penalty = newValue}
  }
  /// Returns true if `penalty` has been explicitly set.
  public var hasPenalty: Bool {return self._penalty != nil}
  /// Clears the value of `penalty`. Subsequent reads from it will return its default value.
  public mutating func clearPenalty() {self._penalty = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _halftime: Afcon_ScoreDetail? = nil
  fileprivate var _fulltime: Afcon_ScoreDetail? = nil
  fileprivate var _extratime: Afcon_ScoreDetail? = nil
  fileprivate var _penalty: Afcon_ScoreDetail? = nil
}

public struct Afcon_ScoreDetail: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var home: Int32 = 0

  public var away: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Live Match Streaming
public struct Afcon_LiveMatchRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var leagueID: Int32 = 0

  public var season: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Afcon_LiveMatchUpdate: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var fixtureID: Int32 {
    get {return _storage._fixtureID}
    set {_uniqueStorage()._fixtureID = newValue}
  }

  public var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  public var hasTimestamp: Bool {return _storage._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  public mutating func clearTimestamp() {_uniqueStorage()._timestamp = nil}

  /// "goal", "card", "substitution", "status_update", "var"
  public var eventType: String {
    get {return _storage._eventType}
    set {_uniqueStorage()._eventType = newValue}
  }

  public var fixture: Afcon_Fixture {
    get {return _storage._fixture ?? Afcon_Fixture()}
    set {_uniqueStorage()._fixture = newValue}
  }
  /// Returns true if `fixture` has been explicitly set.
  public var hasFixture: Bool {return _storage._fixture != nil}
  /// Clears the value of `fixture`. Subsequent reads from it will return its default value.
  public mutating func clearFixture() {_uniqueStorage()._fixture = nil}

  public var event: Afcon_FixtureEvent {
    get {return _storage._event ?? Afcon_FixtureEvent()}
    set {_uniqueStorage()._event = newValue}
  }
  /// Returns true if `event` has been explicitly set.
  public var hasEvent: Bool {return _storage._event != nil}
  /// Clears the value of `event`. Subsequent reads from it will return its default value.
  public mutating func clearEvent() {_uniqueStorage()._event = nil}

  /// Materialized status for easy access
  public var status: Afcon_FixtureStatus {
    get {return _storage._status ?? Afcon_FixtureStatus()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {_uniqueStorage()._status = nil}

  /// Recent events (last 5 minutes)
  public var recentEvents: [Afcon_FixtureEvent] {
    get {return _storage._recentEvents}
    set {_uniqueStorage()._recentEvents = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Standings Request/Response
public struct Afcon_StandingsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var leagueID: Int32 = 0

  public var season: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Afcon_StandingsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var groups: [Afcon_StandingGroup] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Afcon_StandingGroup: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var groupName: String = String()

  public var standings: [Afcon_Standing] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Afcon_Standing: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var rank: Int32 {
    get {return _storage._rank}
    set {_uniqueStorage()._rank = newValue}
  }

  public var team: Afcon_Team {
    get {return _storage._team ?? Afcon_Team()}
    set {_uniqueStorage()._team = newValue}
  }
  /// Returns true if `team` has been explicitly set.
  public var hasTeam: Bool {return _storage._team != nil}
  /// Clears the value of `team`. Subsequent reads from it will return its default value.
  public mutating func clearTeam() {_uniqueStorage()._team = nil}

  public var points: Int32 {
    get {return _storage._points}
    set {_uniqueStorage()._points = newValue}
  }

  public var goalsDiff: Int32 {
    get {return _storage._goalsDiff}
    set {_uniqueStorage()._goalsDiff = newValue}
  }

  public var group: String {
    get {return _storage._group}
    set {_uniqueStorage()._group = newValue}
  }

  public var form: String {
    get {return _storage._form}
    set {_uniqueStorage()._form = newValue}
  }

  public var status: String {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  public var all: Afcon_StandingStats {
    get {return _storage._all ?? Afcon_StandingStats()}
    set {_uniqueStorage()._all = newValue}
  }
  /// Returns true if `all` has been explicitly set.
  public var hasAll: Bool {return _storage._all != nil}
  /// Clears the value of `all`. Subsequent reads from it will return its default value.
  public mutating func clearAll() {_uniqueStorage()._all = nil}

  public var home: Afcon_StandingStats {
    get {return _storage._home ?? Afcon_StandingStats()}
    set {_uniqueStorage()._home = newValue}
  }
  /// Returns true if `home` has been explicitly set.
  public var hasHome: Bool {return _storage._home != nil}
  /// Clears the value of `home`. Subsequent reads from it will return its default value.
  public mutating func clearHome() {_uniqueStorage()._home = nil}

  public var away: Afcon_StandingStats {
    get {return _storage._away ?? Afcon_StandingStats()}
    set {_uniqueStorage()._away = newValue}
  }
  /// Returns true if `away` has been explicitly set.
  public var hasAway: Bool {return _storage._away != nil}
  /// Clears the value of `away`. Subsequent reads from it will return its default value.
  public mutating func clearAway() {_uniqueStorage()._away = nil}

  public var update: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._update ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._update = newValue}
  }
  /// Returns true if `update` has been explicitly set.
  public var hasUpdate: Bool {return _storage._update != nil}
  /// Clears the value of `update`. Subsequent reads from it will return its default value.
  public mutating func clearUpdate() {_uniqueStorage()._update = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Afcon_StandingStats: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var played: Int32 = 0

  public var win: Int32 = 0

  public var draw: Int32 = 0

  public var lose: Int32 = 0

  public var goals: Afcon_StandingGoals {
    get {return _goals ?? Afcon_StandingGoals()}
    set {_goals = newValue}
  }
  /// Returns true if `goals` has been explicitly set.
  public var hasGoals: Bool {return self._goals != nil}
  /// Clears the value of `goals`. Subsequent reads from it will return its default value.
  public mutating func clearGoals() {self._goals = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _goals: Afcon_StandingGoals? = nil
}

public struct Afcon_StandingGoals: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var `for`: Int32 = 0

  public var against: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Team Details Request/Response
public struct Afcon_TeamDetailsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var teamID: Int32 = 0

  public var season: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Afcon_TeamDetailsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var team: Afcon_Team {
    get {return _team ?? Afcon_Team()}
    set {_team = newValue}
  }
  /// Returns true if `team` has been explicitly set.
  public var hasTeam: Bool {return self._team != nil}
  /// Clears the value of `team`. Subsequent reads from it will return its default value.
  public mutating func clearTeam() {self._team = nil}

  public var venue: Afcon_Venue {
    get {return _venue ?? Afcon_Venue()}
    set {_venue = newValue}
  }
  /// Returns true if `venue` has been explicitly set.
  public var hasVenue: Bool {return self._venue != nil}
  /// Clears the value of `venue`. Subsequent reads from it will return its default value.
  public mutating func clearVenue() {self._venue = nil}

  public var players: [Afcon_Player] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _team: Afcon_Team? = nil
  fileprivate var _venue: Afcon_Venue? = nil
}

public struct Afcon_Player: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int32 = 0

  public var name: String = String()

  public var firstname: String = String()

  public var lastname: String = String()

  public var age: Int32 = 0

  public var birth: Afcon_Birth {
    get {return _birth ?? Afcon_Birth()}
    set {_birth = newValue}
  }
  /// Returns true if `birth` has been explicitly set.
  public var hasBirth: Bool {return self._birth != nil}
  /// Clears the value of `birth`. Subsequent reads from it will return its default value.
  public mutating func clearBirth() {self._birth = nil}

  public var nationality: String = String()

  public var height: String = String()

  public var weight: String = String()

  public var injured: Bool = false

  public var photo: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _birth: Afcon_Birth? = nil
}

public struct Afcon_Birth: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var date: String = String()

  public var place: String = String()

  public var country: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Lineups Request/Response
public struct Afcon_LineupsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var fixtureID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Afcon_LineupsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var lineups: [Afcon_FixtureLineup] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Afcon_FixtureLineup: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var team: Afcon_LineupTeam {
    get {return _team ?? Afcon_LineupTeam()}
    set {_team = newValue}
  }
  /// Returns true if `team` has been explicitly set.
  public var hasTeam: Bool {return self._team != nil}
  /// Clears the value of `team`. Subsequent reads from it will return its default value.
  public mutating func clearTeam() {self._team = nil}

  public var coach: Afcon_LineupCoach {
    get {return _coach ?? Afcon_LineupCoach()}
    set {_coach = newValue}
  }
  /// Returns true if `coach` has been explicitly set.
  public var hasCoach: Bool {return self._coach != nil}
  /// Clears the value of `coach`. Subsequent reads from it will return its default value.
  public mutating func clearCoach() {self._coach = nil}

  public var formation: String = String()

  public var startXi: [Afcon_LineupPlayerPosition] = []

  public var substitutes: [Afcon_LineupPlayerPosition] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _team: Afcon_LineupTeam? = nil
  fileprivate var _coach: Afcon_LineupCoach? = nil
}

public struct Afcon_LineupTeam: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int32 = 0

  public var name: String = String()

  public var logo: String = String()

  public var colors: Afcon_TeamColors {
    get {return _colors ?? Afcon_TeamColors()}
    set {_colors = newValue}
  }
  /// Returns true if `colors` has been explicitly set.
  public var hasColors: Bool {return self._colors != nil}
  /// Clears the value of `colors`. Subsequent reads from it will return its default value.
  public mutating func clearColors() {self._colors = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _colors: Afcon_TeamColors? = nil
}

public struct Afcon_TeamColors: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var player: Afcon_ColorInfo {
    get {return _player ?? Afcon_ColorInfo()}
    set {_player = newValue}
  }
  /// Returns true if `player` has been explicitly set.
  public var hasPlayer: Bool {return self._player != nil}
  /// Clears the value of `player`. Subsequent reads from it will return its default value.
  public mutating func clearPlayer() {self._player = nil}

  public var goalkeeper: Afcon_ColorInfo {
    get {return _goalkeeper ?? Afcon_ColorInfo()}
    set {_goalkeeper = newValue}
  }
  /// Returns true if `goalkeeper` has been explicitly set.
  public var hasGoalkeeper: Bool {return self._goalkeeper != nil}
  /// Clears the value of `goalkeeper`. Subsequent reads from it will return its default value.
  public mutating func clearGoalkeeper() {self._goalkeeper = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _player: Afcon_ColorInfo? = nil
  fileprivate var _goalkeeper: Afcon_ColorInfo? = nil
}

public struct Afcon_ColorInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var primary: String = String()

  public var number: String = String()

  public var border: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Afcon_LineupCoach: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int32 = 0

  public var name: String = String()

  public var photo: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Afcon_LineupPlayerPosition: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var player: Afcon_LineupPlayer {
    get {return _player ?? Afcon_LineupPlayer()}
    set {_player = newValue}
  }
  /// Returns true if `player` has been explicitly set.
  public var hasPlayer: Bool {return self._player != nil}
  /// Clears the value of `player`. Subsequent reads from it will return its default value.
  public mutating func clearPlayer() {self._player = nil}

  public var grid: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _player: Afcon_LineupPlayer? = nil
}

public struct Afcon_LineupPlayer: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int32 = 0

  public var name: String = String()

  public var number: Int32 = 0

  public var pos: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Sync Fixtures Request/Response
public struct Afcon_SyncFixturesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var leagueID: Int32 = 0

  public var season: Int32 = 0

  /// e.g., "AFCON 2025"
  public var competition: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Afcon_SyncFixturesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var fixturesSynced: Int32 = 0

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Device Registration
public struct Afcon_RegisterDeviceRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: String = String()

  public var deviceToken: String = String()

  /// "ios" or "android"
  public var platform: String = String()

  public var deviceID: String = String()

  public var appVersion: String = String()

  public var osVersion: String = String()

  public var language: String = String()

  public var timezone: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Afcon_RegisterDeviceResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  /// UUID assigned by server
  public var deviceUuid: String = String()

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Update Device Token (for token refresh)
public struct Afcon_UpdateDeviceTokenRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var deviceUuid: String = String()

  public var newDeviceToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Afcon_UpdateDeviceTokenResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Subscription Management
public struct Afcon_UpdateSubscriptionsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var deviceUuid: String = String()

  public var subscriptions: [Afcon_Subscription] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Afcon_Subscription: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var leagueID: Int32 = 0

  public var season: Int32 = 0

  /// 0 = all teams in league
  public var teamID: Int32 = 0

  public var preferences: Afcon_NotificationPreferences {
    get {return _preferences ?? Afcon_NotificationPreferences()}
    set {_preferences = newValue}
  }
  /// Returns true if `preferences` has been explicitly set.
  public var hasPreferences: Bool {return self._preferences != nil}
  /// Clears the value of `preferences`. Subsequent reads from it will return its default value.
  public mutating func clearPreferences() {self._preferences = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _preferences: Afcon_NotificationPreferences? = nil
}

public struct Afcon_NotificationPreferences: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var notifyGoals: Bool = false

  public var notifyMatchStart: Bool = false

  public var notifyMatchEnd: Bool = false

  public var notifyRedCards: Bool = false

  public var notifyLineups: Bool = false

  public var notifyVar: Bool = false

  /// 5, 10, 15, 30, 60
  public var matchStartMinutesBefore: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Afcon_UpdateSubscriptionsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var subscriptionsUpdated: Int32 = 0

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Get Subscriptions
public struct Afcon_GetSubscriptionsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var deviceUuid: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Afcon_GetSubscriptionsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var subscriptions: [Afcon_Subscription] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Unregister Device
public struct Afcon_UnregisterDeviceRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var deviceUuid: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Afcon_UnregisterDeviceResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Start Live Activity
public struct Afcon_StartLiveActivityRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var deviceUuid: String = String()

  public var fixtureID: Int32 = 0

  /// iOS ActivityKit ID
  public var activityID: String = String()

  /// Push-to-update token
  public var pushToken: String = String()

  /// "every_minute", "goals_only", "major_events", "all_events"
  public var updateFrequency: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Afcon_StartLiveActivityResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var message: String = String()

  /// Server-assigned UUID
  public var activityUuid: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Update Live Activity Preferences
public struct Afcon_UpdateLiveActivityRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var activityUuid: String = String()

  /// Change update frequency
  public var updateFrequency: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Afcon_UpdateLiveActivityResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// End Live Activity
public struct Afcon_EndLiveActivityRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var activityUuid: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Afcon_EndLiveActivityResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Get Active Live Activities
public struct Afcon_GetActiveLiveActivitiesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var deviceUuid: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Afcon_GetActiveLiveActivitiesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var activities: [Afcon_LiveActivityInfo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Afcon_LiveActivityInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var activityUuid: String = String()

  public var fixtureID: Int32 = 0

  public var activityID: String = String()

  public var updateFrequency: String = String()

  public var startedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startedAt = newValue}
  }
  /// Returns true if `startedAt` has been explicitly set.
  public var hasStartedAt: Bool {return self._startedAt != nil}
  /// Clears the value of `startedAt`. Subsequent reads from it will return its default value.
  public mutating func clearStartedAt() {self._startedAt = nil}

  public var expiresAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expiresAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expiresAt = newValue}
  }
  /// Returns true if `expiresAt` has been explicitly set.
  public var hasExpiresAt: Bool {return self._expiresAt != nil}
  /// Clears the value of `expiresAt`. Subsequent reads from it will return its default value.
  public mutating func clearExpiresAt() {self._expiresAt = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _startedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _expiresAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Live Activity Content State (for push updates)
public struct Afcon_LiveActivityContentState: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var fixtureID: Int32 = 0

  public var homeTeam: String = String()

  public var awayTeam: String = String()

  public var homeScore: Int32 = 0

  public var awayScore: Int32 = 0

  /// "NS", "1H", "HT", "2H", "ET", "FT"
  public var status: String = String()

  public var elapsed: Int32 = 0

  /// "Goal by Salah 45'", "Red Card 67'", etc.
  public var lastEvent: String = String()

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {self._updatedAt = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "afcon"

extension Afcon_LeagueRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LeagueRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}league_id\0\u{1}season\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.leagueID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.season) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.leagueID != 0 {
      try visitor.visitSingularInt32Field(value: self.leagueID, fieldNumber: 1)
    }
    if self.season != 0 {
      try visitor.visitSingularInt32Field(value: self.season, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_LeagueRequest, rhs: Afcon_LeagueRequest) -> Bool {
    if lhs.leagueID != rhs.leagueID {return false}
    if lhs.season != rhs.season {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_LeagueResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LeagueResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}league\0\u{1}country\0\u{1}seasons\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._league) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._country) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.seasons) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._league {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._country {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.seasons.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.seasons, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_LeagueResponse, rhs: Afcon_LeagueResponse) -> Bool {
    if lhs._league != rhs._league {return false}
    if lhs._country != rhs._country {return false}
    if lhs.seasons != rhs.seasons {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_League: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".League"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}name\0\u{1}type\0\u{1}logo\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.logo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 3)
    }
    if !self.logo.isEmpty {
      try visitor.visitSingularStringField(value: self.logo, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_League, rhs: Afcon_League) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.type != rhs.type {return false}
    if lhs.logo != rhs.logo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_Country: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Country"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}code\0\u{1}flag\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.code) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.flag) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.code.isEmpty {
      try visitor.visitSingularStringField(value: self.code, fieldNumber: 2)
    }
    if !self.flag.isEmpty {
      try visitor.visitSingularStringField(value: self.flag, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_Country, rhs: Afcon_Country) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.code != rhs.code {return false}
    if lhs.flag != rhs.flag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_Season: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Season"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}year\0\u{1}start\0\u{1}end\0\u{1}current\0\u{1}coverage\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.year) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.start) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.end) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.current) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._coverage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.year != 0 {
      try visitor.visitSingularInt32Field(value: self.year, fieldNumber: 1)
    }
    if !self.start.isEmpty {
      try visitor.visitSingularStringField(value: self.start, fieldNumber: 2)
    }
    if !self.end.isEmpty {
      try visitor.visitSingularStringField(value: self.end, fieldNumber: 3)
    }
    if self.current != false {
      try visitor.visitSingularBoolField(value: self.current, fieldNumber: 4)
    }
    try { if let v = self._coverage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_Season, rhs: Afcon_Season) -> Bool {
    if lhs.year != rhs.year {return false}
    if lhs.start != rhs.start {return false}
    if lhs.end != rhs.end {return false}
    if lhs.current != rhs.current {return false}
    if lhs._coverage != rhs._coverage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_Coverage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Coverage"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}fixtures\0\u{1}standings\0\u{1}players\0\u{3}top_scorers\0\u{3}top_assists\0\u{3}top_cards\0\u{1}injuries\0\u{1}predictions\0\u{1}odds\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._fixtures) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.standings) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.players) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.topScorers) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.topAssists) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.topCards) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.injuries) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.predictions) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.odds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._fixtures {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.standings != false {
      try visitor.visitSingularBoolField(value: self.standings, fieldNumber: 2)
    }
    if self.players != false {
      try visitor.visitSingularBoolField(value: self.players, fieldNumber: 3)
    }
    if self.topScorers != false {
      try visitor.visitSingularBoolField(value: self.topScorers, fieldNumber: 4)
    }
    if self.topAssists != false {
      try visitor.visitSingularBoolField(value: self.topAssists, fieldNumber: 5)
    }
    if self.topCards != false {
      try visitor.visitSingularBoolField(value: self.topCards, fieldNumber: 6)
    }
    if self.injuries != false {
      try visitor.visitSingularBoolField(value: self.injuries, fieldNumber: 7)
    }
    if self.predictions != false {
      try visitor.visitSingularBoolField(value: self.predictions, fieldNumber: 8)
    }
    if self.odds != false {
      try visitor.visitSingularBoolField(value: self.odds, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_Coverage, rhs: Afcon_Coverage) -> Bool {
    if lhs._fixtures != rhs._fixtures {return false}
    if lhs.standings != rhs.standings {return false}
    if lhs.players != rhs.players {return false}
    if lhs.topScorers != rhs.topScorers {return false}
    if lhs.topAssists != rhs.topAssists {return false}
    if lhs.topCards != rhs.topCards {return false}
    if lhs.injuries != rhs.injuries {return false}
    if lhs.predictions != rhs.predictions {return false}
    if lhs.odds != rhs.odds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_FixtureCoverage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FixtureCoverage"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}events\0\u{1}lineups\0\u{3}statistics_fixtures\0\u{3}statistics_players\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.events) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.lineups) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.statisticsFixtures) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.statisticsPlayers) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.events != false {
      try visitor.visitSingularBoolField(value: self.events, fieldNumber: 1)
    }
    if self.lineups != false {
      try visitor.visitSingularBoolField(value: self.lineups, fieldNumber: 2)
    }
    if self.statisticsFixtures != false {
      try visitor.visitSingularBoolField(value: self.statisticsFixtures, fieldNumber: 3)
    }
    if self.statisticsPlayers != false {
      try visitor.visitSingularBoolField(value: self.statisticsPlayers, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_FixtureCoverage, rhs: Afcon_FixtureCoverage) -> Bool {
    if lhs.events != rhs.events {return false}
    if lhs.lineups != rhs.lineups {return false}
    if lhs.statisticsFixtures != rhs.statisticsFixtures {return false}
    if lhs.statisticsPlayers != rhs.statisticsPlayers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_TeamsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TeamsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}league_id\0\u{1}season\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.leagueID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.season) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.leagueID != 0 {
      try visitor.visitSingularInt32Field(value: self.leagueID, fieldNumber: 1)
    }
    if self.season != 0 {
      try visitor.visitSingularInt32Field(value: self.season, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_TeamsRequest, rhs: Afcon_TeamsRequest) -> Bool {
    if lhs.leagueID != rhs.leagueID {return false}
    if lhs.season != rhs.season {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_TeamsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TeamsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}teams\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.teams) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.teams.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.teams, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_TeamsResponse, rhs: Afcon_TeamsResponse) -> Bool {
    if lhs.teams != rhs.teams {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_TeamInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TeamInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}team\0\u{1}venue\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._team) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._venue) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._team {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._venue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_TeamInfo, rhs: Afcon_TeamInfo) -> Bool {
    if lhs._team != rhs._team {return false}
    if lhs._venue != rhs._venue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_Team: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Team"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}name\0\u{1}code\0\u{1}country\0\u{1}founded\0\u{1}national\0\u{1}logo\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.code) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.country) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.founded) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.national) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.logo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.code.isEmpty {
      try visitor.visitSingularStringField(value: self.code, fieldNumber: 3)
    }
    if !self.country.isEmpty {
      try visitor.visitSingularStringField(value: self.country, fieldNumber: 4)
    }
    if self.founded != 0 {
      try visitor.visitSingularInt32Field(value: self.founded, fieldNumber: 5)
    }
    if self.national != false {
      try visitor.visitSingularBoolField(value: self.national, fieldNumber: 6)
    }
    if !self.logo.isEmpty {
      try visitor.visitSingularStringField(value: self.logo, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_Team, rhs: Afcon_Team) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.code != rhs.code {return false}
    if lhs.country != rhs.country {return false}
    if lhs.founded != rhs.founded {return false}
    if lhs.national != rhs.national {return false}
    if lhs.logo != rhs.logo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_Venue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Venue"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}name\0\u{1}address\0\u{1}city\0\u{1}capacity\0\u{1}surface\0\u{1}image\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.city) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.capacity) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.surface) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.image) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 3)
    }
    if !self.city.isEmpty {
      try visitor.visitSingularStringField(value: self.city, fieldNumber: 4)
    }
    if self.capacity != 0 {
      try visitor.visitSingularInt32Field(value: self.capacity, fieldNumber: 5)
    }
    if !self.surface.isEmpty {
      try visitor.visitSingularStringField(value: self.surface, fieldNumber: 6)
    }
    if !self.image.isEmpty {
      try visitor.visitSingularStringField(value: self.image, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_Venue, rhs: Afcon_Venue) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.address != rhs.address {return false}
    if lhs.city != rhs.city {return false}
    if lhs.capacity != rhs.capacity {return false}
    if lhs.surface != rhs.surface {return false}
    if lhs.image != rhs.image {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_FixturesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FixturesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}league_id\0\u{1}season\0\u{1}date\0\u{3}team_id\0\u{1}live\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.leagueID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.season) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.date) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.teamID) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.live) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.leagueID != 0 {
      try visitor.visitSingularInt32Field(value: self.leagueID, fieldNumber: 1)
    }
    if self.season != 0 {
      try visitor.visitSingularInt32Field(value: self.season, fieldNumber: 2)
    }
    if !self.date.isEmpty {
      try visitor.visitSingularStringField(value: self.date, fieldNumber: 3)
    }
    if self.teamID != 0 {
      try visitor.visitSingularInt32Field(value: self.teamID, fieldNumber: 4)
    }
    if self.live != false {
      try visitor.visitSingularBoolField(value: self.live, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_FixturesRequest, rhs: Afcon_FixturesRequest) -> Bool {
    if lhs.leagueID != rhs.leagueID {return false}
    if lhs.season != rhs.season {return false}
    if lhs.date != rhs.date {return false}
    if lhs.teamID != rhs.teamID {return false}
    if lhs.live != rhs.live {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_FixturesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FixturesResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}fixtures\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.fixtures) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fixtures.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fixtures, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_FixturesResponse, rhs: Afcon_FixturesResponse) -> Bool {
    if lhs.fixtures != rhs.fixtures {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_TodayUpcomingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TodayUpcomingRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}league_id\0\u{1}season\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.leagueID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.season) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.leagueID != 0 {
      try visitor.visitSingularInt32Field(value: self.leagueID, fieldNumber: 1)
    }
    if self.season != 0 {
      try visitor.visitSingularInt32Field(value: self.season, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_TodayUpcomingRequest, rhs: Afcon_TodayUpcomingRequest) -> Bool {
    if lhs.leagueID != rhs.leagueID {return false}
    if lhs.season != rhs.season {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_FixtureByIdRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FixtureByIdRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}fixture_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.fixtureID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.fixtureID != 0 {
      try visitor.visitSingularInt32Field(value: self.fixtureID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_FixtureByIdRequest, rhs: Afcon_FixtureByIdRequest) -> Bool {
    if lhs.fixtureID != rhs.fixtureID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_FixtureResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FixtureResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}fixture\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._fixture) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._fixture {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_FixtureResponse, rhs: Afcon_FixtureResponse) -> Bool {
    if lhs._fixture != rhs._fixture {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_FixtureEventsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FixtureEventsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}fixture_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.fixtureID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.fixtureID != 0 {
      try visitor.visitSingularInt32Field(value: self.fixtureID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_FixtureEventsRequest, rhs: Afcon_FixtureEventsRequest) -> Bool {
    if lhs.fixtureID != rhs.fixtureID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_FixtureEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FixtureEvent"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}time\0\u{1}team\0\u{1}player\0\u{1}assist\0\u{1}type\0\u{1}detail\0\u{1}comments\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._team) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._player) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._assist) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.detail) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.comments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._team {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._player {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._assist {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 5)
    }
    if !self.detail.isEmpty {
      try visitor.visitSingularStringField(value: self.detail, fieldNumber: 6)
    }
    if !self.comments.isEmpty {
      try visitor.visitSingularStringField(value: self.comments, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_FixtureEvent, rhs: Afcon_FixtureEvent) -> Bool {
    if lhs._time != rhs._time {return false}
    if lhs._team != rhs._team {return false}
    if lhs._player != rhs._player {return false}
    if lhs._assist != rhs._assist {return false}
    if lhs.type != rhs.type {return false}
    if lhs.detail != rhs.detail {return false}
    if lhs.comments != rhs.comments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_EventTime: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventTime"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}elapsed\0\u{1}extra\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.elapsed) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.extra) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.elapsed != 0 {
      try visitor.visitSingularInt32Field(value: self.elapsed, fieldNumber: 1)
    }
    if self.extra != 0 {
      try visitor.visitSingularInt32Field(value: self.extra, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_EventTime, rhs: Afcon_EventTime) -> Bool {
    if lhs.elapsed != rhs.elapsed {return false}
    if lhs.extra != rhs.extra {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_EventTeam: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventTeam"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}name\0\u{1}logo\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.logo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.logo.isEmpty {
      try visitor.visitSingularStringField(value: self.logo, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_EventTeam, rhs: Afcon_EventTeam) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.logo != rhs.logo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_EventPlayer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventPlayer"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}name\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_EventPlayer, rhs: Afcon_EventPlayer) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_FixtureEventsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FixtureEventsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}events\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.events) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.events.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.events, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_FixtureEventsResponse, rhs: Afcon_FixtureEventsResponse) -> Bool {
    if lhs.events != rhs.events {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_FixturesByDateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FixturesByDateRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}date\0\u{3}league_id\0\u{1}season\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.date) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.leagueID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.season) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.date.isEmpty {
      try visitor.visitSingularStringField(value: self.date, fieldNumber: 1)
    }
    if self.leagueID != 0 {
      try visitor.visitSingularInt32Field(value: self.leagueID, fieldNumber: 2)
    }
    if self.season != 0 {
      try visitor.visitSingularInt32Field(value: self.season, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_FixturesByDateRequest, rhs: Afcon_FixturesByDateRequest) -> Bool {
    if lhs.date != rhs.date {return false}
    if lhs.leagueID != rhs.leagueID {return false}
    if lhs.season != rhs.season {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_NextUpcomingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NextUpcomingRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}league_id\0\u{1}season\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.leagueID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.season) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.leagueID != 0 {
      try visitor.visitSingularInt32Field(value: self.leagueID, fieldNumber: 1)
    }
    if self.season != 0 {
      try visitor.visitSingularInt32Field(value: self.season, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_NextUpcomingRequest, rhs: Afcon_NextUpcomingRequest) -> Bool {
    if lhs.leagueID != rhs.leagueID {return false}
    if lhs.season != rhs.season {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_Fixture: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Fixture"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}referee\0\u{1}timezone\0\u{1}date\0\u{1}timestamp\0\u{1}periods\0\u{1}venue\0\u{1}status\0\u{1}teams\0\u{1}goals\0\u{1}score\0\u{1}league\0")

  fileprivate class _StorageClass {
    var _id: Int32 = 0
    var _referee: String = String()
    var _timezone: String = String()
    var _date: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _timestamp: Int32 = 0
    var _periods: Afcon_FixturePeriods? = nil
    var _venue: Afcon_FixtureVenue? = nil
    var _status: Afcon_FixtureStatus? = nil
    var _teams: Afcon_FixtureTeams? = nil
    var _goals: Afcon_FixtureGoals? = nil
    var _score: Afcon_FixtureScore? = nil
    var _league: Afcon_FixtureLeague? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _referee = source._referee
      _timezone = source._timezone
      _date = source._date
      _timestamp = source._timestamp
      _periods = source._periods
      _venue = source._venue
      _status = source._status
      _teams = source._teams
      _goals = source._goals
      _score = source._score
      _league = source._league
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._referee) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._timezone) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._date) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._timestamp) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._periods) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._venue) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._teams) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._goals) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._score) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._league) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._id != 0 {
        try visitor.visitSingularInt32Field(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._referee.isEmpty {
        try visitor.visitSingularStringField(value: _storage._referee, fieldNumber: 2)
      }
      if !_storage._timezone.isEmpty {
        try visitor.visitSingularStringField(value: _storage._timezone, fieldNumber: 3)
      }
      try { if let v = _storage._date {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if _storage._timestamp != 0 {
        try visitor.visitSingularInt32Field(value: _storage._timestamp, fieldNumber: 5)
      }
      try { if let v = _storage._periods {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._venue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._teams {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._goals {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._score {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._league {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_Fixture, rhs: Afcon_Fixture) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._referee != rhs_storage._referee {return false}
        if _storage._timezone != rhs_storage._timezone {return false}
        if _storage._date != rhs_storage._date {return false}
        if _storage._timestamp != rhs_storage._timestamp {return false}
        if _storage._periods != rhs_storage._periods {return false}
        if _storage._venue != rhs_storage._venue {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._teams != rhs_storage._teams {return false}
        if _storage._goals != rhs_storage._goals {return false}
        if _storage._score != rhs_storage._score {return false}
        if _storage._league != rhs_storage._league {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_FixtureLeague: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FixtureLeague"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}name\0\u{1}season\0\u{1}round\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.season) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.round) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.season != 0 {
      try visitor.visitSingularInt32Field(value: self.season, fieldNumber: 3)
    }
    if !self.round.isEmpty {
      try visitor.visitSingularStringField(value: self.round, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_FixtureLeague, rhs: Afcon_FixtureLeague) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.season != rhs.season {return false}
    if lhs.round != rhs.round {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_FixturePeriods: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FixturePeriods"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}first\0\u{1}second\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.first) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.second) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.first != 0 {
      try visitor.visitSingularInt32Field(value: self.first, fieldNumber: 1)
    }
    if self.second != 0 {
      try visitor.visitSingularInt32Field(value: self.second, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_FixturePeriods, rhs: Afcon_FixturePeriods) -> Bool {
    if lhs.first != rhs.first {return false}
    if lhs.second != rhs.second {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_FixtureVenue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FixtureVenue"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}name\0\u{1}city\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.city) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.city.isEmpty {
      try visitor.visitSingularStringField(value: self.city, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_FixtureVenue, rhs: Afcon_FixtureVenue) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.city != rhs.city {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_FixtureStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FixtureStatus"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}long\0\u{1}short\0\u{1}elapsed\0\u{1}extra\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.long) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.short) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.elapsed) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.extra) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.long.isEmpty {
      try visitor.visitSingularStringField(value: self.long, fieldNumber: 1)
    }
    if !self.short.isEmpty {
      try visitor.visitSingularStringField(value: self.short, fieldNumber: 2)
    }
    if self.elapsed != 0 {
      try visitor.visitSingularInt32Field(value: self.elapsed, fieldNumber: 3)
    }
    if self.extra != 0 {
      try visitor.visitSingularInt32Field(value: self.extra, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_FixtureStatus, rhs: Afcon_FixtureStatus) -> Bool {
    if lhs.long != rhs.long {return false}
    if lhs.short != rhs.short {return false}
    if lhs.elapsed != rhs.elapsed {return false}
    if lhs.extra != rhs.extra {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_FixtureTeams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FixtureTeams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}home\0\u{1}away\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._home) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._away) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._home {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._away {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_FixtureTeams, rhs: Afcon_FixtureTeams) -> Bool {
    if lhs._home != rhs._home {return false}
    if lhs._away != rhs._away {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_FixtureTeam: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FixtureTeam"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}name\0\u{1}logo\0\u{1}winner\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.logo) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.winner) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.logo.isEmpty {
      try visitor.visitSingularStringField(value: self.logo, fieldNumber: 3)
    }
    if self.winner != false {
      try visitor.visitSingularBoolField(value: self.winner, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_FixtureTeam, rhs: Afcon_FixtureTeam) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.logo != rhs.logo {return false}
    if lhs.winner != rhs.winner {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_FixtureGoals: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FixtureGoals"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}home\0\u{1}away\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.home) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.away) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.home != 0 {
      try visitor.visitSingularInt32Field(value: self.home, fieldNumber: 1)
    }
    if self.away != 0 {
      try visitor.visitSingularInt32Field(value: self.away, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_FixtureGoals, rhs: Afcon_FixtureGoals) -> Bool {
    if lhs.home != rhs.home {return false}
    if lhs.away != rhs.away {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_FixtureScore: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FixtureScore"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}halftime\0\u{1}fulltime\0\u{1}extratime\0\u{1}penalty\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._halftime) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._fulltime) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._extratime) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._penalty) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._halftime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._fulltime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._extratime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._penalty {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_FixtureScore, rhs: Afcon_FixtureScore) -> Bool {
    if lhs._halftime != rhs._halftime {return false}
    if lhs._fulltime != rhs._fulltime {return false}
    if lhs._extratime != rhs._extratime {return false}
    if lhs._penalty != rhs._penalty {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_ScoreDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ScoreDetail"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}home\0\u{1}away\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.home) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.away) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.home != 0 {
      try visitor.visitSingularInt32Field(value: self.home, fieldNumber: 1)
    }
    if self.away != 0 {
      try visitor.visitSingularInt32Field(value: self.away, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_ScoreDetail, rhs: Afcon_ScoreDetail) -> Bool {
    if lhs.home != rhs.home {return false}
    if lhs.away != rhs.away {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_LiveMatchRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LiveMatchRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}league_id\0\u{1}season\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.leagueID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.season) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.leagueID != 0 {
      try visitor.visitSingularInt32Field(value: self.leagueID, fieldNumber: 1)
    }
    if self.season != 0 {
      try visitor.visitSingularInt32Field(value: self.season, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_LiveMatchRequest, rhs: Afcon_LiveMatchRequest) -> Bool {
    if lhs.leagueID != rhs.leagueID {return false}
    if lhs.season != rhs.season {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_LiveMatchUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LiveMatchUpdate"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}fixture_id\0\u{1}timestamp\0\u{3}event_type\0\u{1}fixture\0\u{1}event\0\u{1}status\0\u{3}recent_events\0")

  fileprivate class _StorageClass {
    var _fixtureID: Int32 = 0
    var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _eventType: String = String()
    var _fixture: Afcon_Fixture? = nil
    var _event: Afcon_FixtureEvent? = nil
    var _status: Afcon_FixtureStatus? = nil
    var _recentEvents: [Afcon_FixtureEvent] = []

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _fixtureID = source._fixtureID
      _timestamp = source._timestamp
      _eventType = source._eventType
      _fixture = source._fixture
      _event = source._event
      _status = source._status
      _recentEvents = source._recentEvents
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._fixtureID) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._timestamp) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._eventType) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._fixture) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._event) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._recentEvents) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._fixtureID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._fixtureID, fieldNumber: 1)
      }
      try { if let v = _storage._timestamp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._eventType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._eventType, fieldNumber: 3)
      }
      try { if let v = _storage._fixture {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._event {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._recentEvents.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._recentEvents, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_LiveMatchUpdate, rhs: Afcon_LiveMatchUpdate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._fixtureID != rhs_storage._fixtureID {return false}
        if _storage._timestamp != rhs_storage._timestamp {return false}
        if _storage._eventType != rhs_storage._eventType {return false}
        if _storage._fixture != rhs_storage._fixture {return false}
        if _storage._event != rhs_storage._event {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._recentEvents != rhs_storage._recentEvents {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_StandingsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StandingsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}league_id\0\u{1}season\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.leagueID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.season) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.leagueID != 0 {
      try visitor.visitSingularInt32Field(value: self.leagueID, fieldNumber: 1)
    }
    if self.season != 0 {
      try visitor.visitSingularInt32Field(value: self.season, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_StandingsRequest, rhs: Afcon_StandingsRequest) -> Bool {
    if lhs.leagueID != rhs.leagueID {return false}
    if lhs.season != rhs.season {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_StandingsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StandingsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}groups\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.groups) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groups.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groups, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_StandingsResponse, rhs: Afcon_StandingsResponse) -> Bool {
    if lhs.groups != rhs.groups {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_StandingGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StandingGroup"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_name\0\u{1}standings\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.groupName) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.standings) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupName.isEmpty {
      try visitor.visitSingularStringField(value: self.groupName, fieldNumber: 1)
    }
    if !self.standings.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.standings, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_StandingGroup, rhs: Afcon_StandingGroup) -> Bool {
    if lhs.groupName != rhs.groupName {return false}
    if lhs.standings != rhs.standings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_Standing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Standing"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}rank\0\u{1}team\0\u{1}points\0\u{3}goals_diff\0\u{1}group\0\u{1}form\0\u{1}status\0\u{1}description\0\u{1}all\0\u{1}home\0\u{1}away\0\u{1}update\0")

  fileprivate class _StorageClass {
    var _rank: Int32 = 0
    var _team: Afcon_Team? = nil
    var _points: Int32 = 0
    var _goalsDiff: Int32 = 0
    var _group: String = String()
    var _form: String = String()
    var _status: String = String()
    var _description_p: String = String()
    var _all: Afcon_StandingStats? = nil
    var _home: Afcon_StandingStats? = nil
    var _away: Afcon_StandingStats? = nil
    var _update: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _rank = source._rank
      _team = source._team
      _points = source._points
      _goalsDiff = source._goalsDiff
      _group = source._group
      _form = source._form
      _status = source._status
      _description_p = source._description_p
      _all = source._all
      _home = source._home
      _away = source._away
      _update = source._update
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._rank) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._team) }()
        case 3: try { try decoder.decodeSingularInt32Field(value: &_storage._points) }()
        case 4: try { try decoder.decodeSingularInt32Field(value: &_storage._goalsDiff) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._group) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._form) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._status) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._all) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._home) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._away) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._update) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._rank != 0 {
        try visitor.visitSingularInt32Field(value: _storage._rank, fieldNumber: 1)
      }
      try { if let v = _storage._team {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if _storage._points != 0 {
        try visitor.visitSingularInt32Field(value: _storage._points, fieldNumber: 3)
      }
      if _storage._goalsDiff != 0 {
        try visitor.visitSingularInt32Field(value: _storage._goalsDiff, fieldNumber: 4)
      }
      if !_storage._group.isEmpty {
        try visitor.visitSingularStringField(value: _storage._group, fieldNumber: 5)
      }
      if !_storage._form.isEmpty {
        try visitor.visitSingularStringField(value: _storage._form, fieldNumber: 6)
      }
      if !_storage._status.isEmpty {
        try visitor.visitSingularStringField(value: _storage._status, fieldNumber: 7)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 8)
      }
      try { if let v = _storage._all {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._home {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._away {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._update {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_Standing, rhs: Afcon_Standing) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._rank != rhs_storage._rank {return false}
        if _storage._team != rhs_storage._team {return false}
        if _storage._points != rhs_storage._points {return false}
        if _storage._goalsDiff != rhs_storage._goalsDiff {return false}
        if _storage._group != rhs_storage._group {return false}
        if _storage._form != rhs_storage._form {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._all != rhs_storage._all {return false}
        if _storage._home != rhs_storage._home {return false}
        if _storage._away != rhs_storage._away {return false}
        if _storage._update != rhs_storage._update {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_StandingStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StandingStats"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}played\0\u{1}win\0\u{1}draw\0\u{1}lose\0\u{1}goals\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.played) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.win) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.draw) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.lose) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._goals) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.played != 0 {
      try visitor.visitSingularInt32Field(value: self.played, fieldNumber: 1)
    }
    if self.win != 0 {
      try visitor.visitSingularInt32Field(value: self.win, fieldNumber: 2)
    }
    if self.draw != 0 {
      try visitor.visitSingularInt32Field(value: self.draw, fieldNumber: 3)
    }
    if self.lose != 0 {
      try visitor.visitSingularInt32Field(value: self.lose, fieldNumber: 4)
    }
    try { if let v = self._goals {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_StandingStats, rhs: Afcon_StandingStats) -> Bool {
    if lhs.played != rhs.played {return false}
    if lhs.win != rhs.win {return false}
    if lhs.draw != rhs.draw {return false}
    if lhs.lose != rhs.lose {return false}
    if lhs._goals != rhs._goals {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_StandingGoals: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StandingGoals"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}for\0\u{1}against\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.`for`) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.against) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.`for` != 0 {
      try visitor.visitSingularInt32Field(value: self.`for`, fieldNumber: 1)
    }
    if self.against != 0 {
      try visitor.visitSingularInt32Field(value: self.against, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_StandingGoals, rhs: Afcon_StandingGoals) -> Bool {
    if lhs.`for` != rhs.`for` {return false}
    if lhs.against != rhs.against {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_TeamDetailsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TeamDetailsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}team_id\0\u{1}season\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.teamID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.season) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.teamID != 0 {
      try visitor.visitSingularInt32Field(value: self.teamID, fieldNumber: 1)
    }
    if self.season != 0 {
      try visitor.visitSingularInt32Field(value: self.season, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_TeamDetailsRequest, rhs: Afcon_TeamDetailsRequest) -> Bool {
    if lhs.teamID != rhs.teamID {return false}
    if lhs.season != rhs.season {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_TeamDetailsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TeamDetailsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}team\0\u{1}venue\0\u{1}players\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._team) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._venue) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.players) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._team {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._venue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.players.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.players, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_TeamDetailsResponse, rhs: Afcon_TeamDetailsResponse) -> Bool {
    if lhs._team != rhs._team {return false}
    if lhs._venue != rhs._venue {return false}
    if lhs.players != rhs.players {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_Player: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Player"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}name\0\u{1}firstname\0\u{1}lastname\0\u{1}age\0\u{1}birth\0\u{1}nationality\0\u{1}height\0\u{1}weight\0\u{1}injured\0\u{1}photo\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.firstname) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.lastname) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.age) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._birth) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.nationality) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.height) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.weight) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.injured) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.photo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.firstname.isEmpty {
      try visitor.visitSingularStringField(value: self.firstname, fieldNumber: 3)
    }
    if !self.lastname.isEmpty {
      try visitor.visitSingularStringField(value: self.lastname, fieldNumber: 4)
    }
    if self.age != 0 {
      try visitor.visitSingularInt32Field(value: self.age, fieldNumber: 5)
    }
    try { if let v = self._birth {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.nationality.isEmpty {
      try visitor.visitSingularStringField(value: self.nationality, fieldNumber: 7)
    }
    if !self.height.isEmpty {
      try visitor.visitSingularStringField(value: self.height, fieldNumber: 8)
    }
    if !self.weight.isEmpty {
      try visitor.visitSingularStringField(value: self.weight, fieldNumber: 9)
    }
    if self.injured != false {
      try visitor.visitSingularBoolField(value: self.injured, fieldNumber: 10)
    }
    if !self.photo.isEmpty {
      try visitor.visitSingularStringField(value: self.photo, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_Player, rhs: Afcon_Player) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.firstname != rhs.firstname {return false}
    if lhs.lastname != rhs.lastname {return false}
    if lhs.age != rhs.age {return false}
    if lhs._birth != rhs._birth {return false}
    if lhs.nationality != rhs.nationality {return false}
    if lhs.height != rhs.height {return false}
    if lhs.weight != rhs.weight {return false}
    if lhs.injured != rhs.injured {return false}
    if lhs.photo != rhs.photo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_Birth: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Birth"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}date\0\u{1}place\0\u{1}country\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.date) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.place) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.country) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.date.isEmpty {
      try visitor.visitSingularStringField(value: self.date, fieldNumber: 1)
    }
    if !self.place.isEmpty {
      try visitor.visitSingularStringField(value: self.place, fieldNumber: 2)
    }
    if !self.country.isEmpty {
      try visitor.visitSingularStringField(value: self.country, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_Birth, rhs: Afcon_Birth) -> Bool {
    if lhs.date != rhs.date {return false}
    if lhs.place != rhs.place {return false}
    if lhs.country != rhs.country {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_LineupsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LineupsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}fixture_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.fixtureID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.fixtureID != 0 {
      try visitor.visitSingularInt32Field(value: self.fixtureID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_LineupsRequest, rhs: Afcon_LineupsRequest) -> Bool {
    if lhs.fixtureID != rhs.fixtureID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_LineupsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LineupsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}lineups\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.lineups) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.lineups.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.lineups, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_LineupsResponse, rhs: Afcon_LineupsResponse) -> Bool {
    if lhs.lineups != rhs.lineups {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_FixtureLineup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FixtureLineup"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}team\0\u{1}coach\0\u{1}formation\0\u{3}start_xi\0\u{1}substitutes\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._team) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._coach) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.formation) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.startXi) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.substitutes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._team {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._coach {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.formation.isEmpty {
      try visitor.visitSingularStringField(value: self.formation, fieldNumber: 3)
    }
    if !self.startXi.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.startXi, fieldNumber: 4)
    }
    if !self.substitutes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.substitutes, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_FixtureLineup, rhs: Afcon_FixtureLineup) -> Bool {
    if lhs._team != rhs._team {return false}
    if lhs._coach != rhs._coach {return false}
    if lhs.formation != rhs.formation {return false}
    if lhs.startXi != rhs.startXi {return false}
    if lhs.substitutes != rhs.substitutes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_LineupTeam: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LineupTeam"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}name\0\u{1}logo\0\u{1}colors\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.logo) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._colors) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.logo.isEmpty {
      try visitor.visitSingularStringField(value: self.logo, fieldNumber: 3)
    }
    try { if let v = self._colors {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_LineupTeam, rhs: Afcon_LineupTeam) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.logo != rhs.logo {return false}
    if lhs._colors != rhs._colors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_TeamColors: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TeamColors"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}player\0\u{1}goalkeeper\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._player) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._goalkeeper) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._player {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._goalkeeper {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_TeamColors, rhs: Afcon_TeamColors) -> Bool {
    if lhs._player != rhs._player {return false}
    if lhs._goalkeeper != rhs._goalkeeper {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_ColorInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ColorInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}primary\0\u{1}number\0\u{1}border\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.primary) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.number) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.border) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.primary.isEmpty {
      try visitor.visitSingularStringField(value: self.primary, fieldNumber: 1)
    }
    if !self.number.isEmpty {
      try visitor.visitSingularStringField(value: self.number, fieldNumber: 2)
    }
    if !self.border.isEmpty {
      try visitor.visitSingularStringField(value: self.border, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_ColorInfo, rhs: Afcon_ColorInfo) -> Bool {
    if lhs.primary != rhs.primary {return false}
    if lhs.number != rhs.number {return false}
    if lhs.border != rhs.border {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_LineupCoach: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LineupCoach"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}name\0\u{1}photo\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.photo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.photo.isEmpty {
      try visitor.visitSingularStringField(value: self.photo, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_LineupCoach, rhs: Afcon_LineupCoach) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.photo != rhs.photo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_LineupPlayerPosition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LineupPlayerPosition"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}player\0\u{1}grid\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._player) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.grid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._player {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.grid.isEmpty {
      try visitor.visitSingularStringField(value: self.grid, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_LineupPlayerPosition, rhs: Afcon_LineupPlayerPosition) -> Bool {
    if lhs._player != rhs._player {return false}
    if lhs.grid != rhs.grid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_LineupPlayer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LineupPlayer"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}name\0\u{1}number\0\u{1}pos\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.number) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.pos) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.number != 0 {
      try visitor.visitSingularInt32Field(value: self.number, fieldNumber: 3)
    }
    if !self.pos.isEmpty {
      try visitor.visitSingularStringField(value: self.pos, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_LineupPlayer, rhs: Afcon_LineupPlayer) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.number != rhs.number {return false}
    if lhs.pos != rhs.pos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_SyncFixturesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SyncFixturesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}league_id\0\u{1}season\0\u{1}competition\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.leagueID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.season) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.competition) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.leagueID != 0 {
      try visitor.visitSingularInt32Field(value: self.leagueID, fieldNumber: 1)
    }
    if self.season != 0 {
      try visitor.visitSingularInt32Field(value: self.season, fieldNumber: 2)
    }
    if !self.competition.isEmpty {
      try visitor.visitSingularStringField(value: self.competition, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_SyncFixturesRequest, rhs: Afcon_SyncFixturesRequest) -> Bool {
    if lhs.leagueID != rhs.leagueID {return false}
    if lhs.season != rhs.season {return false}
    if lhs.competition != rhs.competition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_SyncFixturesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SyncFixturesResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{3}fixtures_synced\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.fixturesSynced) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if self.fixturesSynced != 0 {
      try visitor.visitSingularInt32Field(value: self.fixturesSynced, fieldNumber: 2)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_SyncFixturesResponse, rhs: Afcon_SyncFixturesResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.fixturesSynced != rhs.fixturesSynced {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_RegisterDeviceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RegisterDeviceRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{3}device_token\0\u{1}platform\0\u{3}device_id\0\u{3}app_version\0\u{3}os_version\0\u{1}language\0\u{1}timezone\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.deviceToken) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.platform) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.appVersion) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.osVersion) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.language) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.timezone) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if !self.deviceToken.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceToken, fieldNumber: 2)
    }
    if !self.platform.isEmpty {
      try visitor.visitSingularStringField(value: self.platform, fieldNumber: 3)
    }
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 4)
    }
    if !self.appVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.appVersion, fieldNumber: 5)
    }
    if !self.osVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.osVersion, fieldNumber: 6)
    }
    if !self.language.isEmpty {
      try visitor.visitSingularStringField(value: self.language, fieldNumber: 7)
    }
    if !self.timezone.isEmpty {
      try visitor.visitSingularStringField(value: self.timezone, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_RegisterDeviceRequest, rhs: Afcon_RegisterDeviceRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.deviceToken != rhs.deviceToken {return false}
    if lhs.platform != rhs.platform {return false}
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.appVersion != rhs.appVersion {return false}
    if lhs.osVersion != rhs.osVersion {return false}
    if lhs.language != rhs.language {return false}
    if lhs.timezone != rhs.timezone {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_RegisterDeviceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RegisterDeviceResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{3}device_uuid\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.deviceUuid) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.deviceUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceUuid, fieldNumber: 2)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_RegisterDeviceResponse, rhs: Afcon_RegisterDeviceResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.deviceUuid != rhs.deviceUuid {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_UpdateDeviceTokenRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateDeviceTokenRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}device_uuid\0\u{3}new_device_token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceUuid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.newDeviceToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceUuid, fieldNumber: 1)
    }
    if !self.newDeviceToken.isEmpty {
      try visitor.visitSingularStringField(value: self.newDeviceToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_UpdateDeviceTokenRequest, rhs: Afcon_UpdateDeviceTokenRequest) -> Bool {
    if lhs.deviceUuid != rhs.deviceUuid {return false}
    if lhs.newDeviceToken != rhs.newDeviceToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_UpdateDeviceTokenResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateDeviceTokenResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_UpdateDeviceTokenResponse, rhs: Afcon_UpdateDeviceTokenResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_UpdateSubscriptionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateSubscriptionsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}device_uuid\0\u{1}subscriptions\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceUuid) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.subscriptions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceUuid, fieldNumber: 1)
    }
    if !self.subscriptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.subscriptions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_UpdateSubscriptionsRequest, rhs: Afcon_UpdateSubscriptionsRequest) -> Bool {
    if lhs.deviceUuid != rhs.deviceUuid {return false}
    if lhs.subscriptions != rhs.subscriptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_Subscription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Subscription"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}league_id\0\u{1}season\0\u{3}team_id\0\u{1}preferences\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.leagueID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.season) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.teamID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._preferences) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.leagueID != 0 {
      try visitor.visitSingularInt32Field(value: self.leagueID, fieldNumber: 1)
    }
    if self.season != 0 {
      try visitor.visitSingularInt32Field(value: self.season, fieldNumber: 2)
    }
    if self.teamID != 0 {
      try visitor.visitSingularInt32Field(value: self.teamID, fieldNumber: 3)
    }
    try { if let v = self._preferences {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_Subscription, rhs: Afcon_Subscription) -> Bool {
    if lhs.leagueID != rhs.leagueID {return false}
    if lhs.season != rhs.season {return false}
    if lhs.teamID != rhs.teamID {return false}
    if lhs._preferences != rhs._preferences {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_NotificationPreferences: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NotificationPreferences"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}notify_goals\0\u{3}notify_match_start\0\u{3}notify_match_end\0\u{3}notify_red_cards\0\u{3}notify_lineups\0\u{3}notify_var\0\u{3}match_start_minutes_before\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.notifyGoals) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.notifyMatchStart) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.notifyMatchEnd) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.notifyRedCards) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.notifyLineups) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.notifyVar) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.matchStartMinutesBefore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.notifyGoals != false {
      try visitor.visitSingularBoolField(value: self.notifyGoals, fieldNumber: 1)
    }
    if self.notifyMatchStart != false {
      try visitor.visitSingularBoolField(value: self.notifyMatchStart, fieldNumber: 2)
    }
    if self.notifyMatchEnd != false {
      try visitor.visitSingularBoolField(value: self.notifyMatchEnd, fieldNumber: 3)
    }
    if self.notifyRedCards != false {
      try visitor.visitSingularBoolField(value: self.notifyRedCards, fieldNumber: 4)
    }
    if self.notifyLineups != false {
      try visitor.visitSingularBoolField(value: self.notifyLineups, fieldNumber: 5)
    }
    if self.notifyVar != false {
      try visitor.visitSingularBoolField(value: self.notifyVar, fieldNumber: 6)
    }
    if self.matchStartMinutesBefore != 0 {
      try visitor.visitSingularInt32Field(value: self.matchStartMinutesBefore, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_NotificationPreferences, rhs: Afcon_NotificationPreferences) -> Bool {
    if lhs.notifyGoals != rhs.notifyGoals {return false}
    if lhs.notifyMatchStart != rhs.notifyMatchStart {return false}
    if lhs.notifyMatchEnd != rhs.notifyMatchEnd {return false}
    if lhs.notifyRedCards != rhs.notifyRedCards {return false}
    if lhs.notifyLineups != rhs.notifyLineups {return false}
    if lhs.notifyVar != rhs.notifyVar {return false}
    if lhs.matchStartMinutesBefore != rhs.matchStartMinutesBefore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_UpdateSubscriptionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateSubscriptionsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{3}subscriptions_updated\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.subscriptionsUpdated) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if self.subscriptionsUpdated != 0 {
      try visitor.visitSingularInt32Field(value: self.subscriptionsUpdated, fieldNumber: 2)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_UpdateSubscriptionsResponse, rhs: Afcon_UpdateSubscriptionsResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.subscriptionsUpdated != rhs.subscriptionsUpdated {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_GetSubscriptionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetSubscriptionsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}device_uuid\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceUuid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceUuid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_GetSubscriptionsRequest, rhs: Afcon_GetSubscriptionsRequest) -> Bool {
    if lhs.deviceUuid != rhs.deviceUuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_GetSubscriptionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetSubscriptionsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}subscriptions\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.subscriptions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subscriptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.subscriptions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_GetSubscriptionsResponse, rhs: Afcon_GetSubscriptionsResponse) -> Bool {
    if lhs.subscriptions != rhs.subscriptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_UnregisterDeviceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnregisterDeviceRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}device_uuid\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceUuid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceUuid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_UnregisterDeviceRequest, rhs: Afcon_UnregisterDeviceRequest) -> Bool {
    if lhs.deviceUuid != rhs.deviceUuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_UnregisterDeviceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnregisterDeviceResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_UnregisterDeviceResponse, rhs: Afcon_UnregisterDeviceResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_StartLiveActivityRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StartLiveActivityRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}device_uuid\0\u{3}fixture_id\0\u{3}activity_id\0\u{3}push_token\0\u{3}update_frequency\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceUuid) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.fixtureID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.activityID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.pushToken) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.updateFrequency) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceUuid, fieldNumber: 1)
    }
    if self.fixtureID != 0 {
      try visitor.visitSingularInt32Field(value: self.fixtureID, fieldNumber: 2)
    }
    if !self.activityID.isEmpty {
      try visitor.visitSingularStringField(value: self.activityID, fieldNumber: 3)
    }
    if !self.pushToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pushToken, fieldNumber: 4)
    }
    if !self.updateFrequency.isEmpty {
      try visitor.visitSingularStringField(value: self.updateFrequency, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_StartLiveActivityRequest, rhs: Afcon_StartLiveActivityRequest) -> Bool {
    if lhs.deviceUuid != rhs.deviceUuid {return false}
    if lhs.fixtureID != rhs.fixtureID {return false}
    if lhs.activityID != rhs.activityID {return false}
    if lhs.pushToken != rhs.pushToken {return false}
    if lhs.updateFrequency != rhs.updateFrequency {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_StartLiveActivityResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StartLiveActivityResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}message\0\u{3}activity_uuid\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.activityUuid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.activityUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.activityUuid, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_StartLiveActivityResponse, rhs: Afcon_StartLiveActivityResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.message != rhs.message {return false}
    if lhs.activityUuid != rhs.activityUuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_UpdateLiveActivityRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateLiveActivityRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}activity_uuid\0\u{3}update_frequency\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.activityUuid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.updateFrequency) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.activityUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.activityUuid, fieldNumber: 1)
    }
    if !self.updateFrequency.isEmpty {
      try visitor.visitSingularStringField(value: self.updateFrequency, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_UpdateLiveActivityRequest, rhs: Afcon_UpdateLiveActivityRequest) -> Bool {
    if lhs.activityUuid != rhs.activityUuid {return false}
    if lhs.updateFrequency != rhs.updateFrequency {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_UpdateLiveActivityResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateLiveActivityResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_UpdateLiveActivityResponse, rhs: Afcon_UpdateLiveActivityResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_EndLiveActivityRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EndLiveActivityRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}activity_uuid\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.activityUuid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.activityUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.activityUuid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_EndLiveActivityRequest, rhs: Afcon_EndLiveActivityRequest) -> Bool {
    if lhs.activityUuid != rhs.activityUuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_EndLiveActivityResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EndLiveActivityResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_EndLiveActivityResponse, rhs: Afcon_EndLiveActivityResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_GetActiveLiveActivitiesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetActiveLiveActivitiesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}device_uuid\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceUuid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceUuid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_GetActiveLiveActivitiesRequest, rhs: Afcon_GetActiveLiveActivitiesRequest) -> Bool {
    if lhs.deviceUuid != rhs.deviceUuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_GetActiveLiveActivitiesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetActiveLiveActivitiesResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}activities\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.activities) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.activities.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.activities, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_GetActiveLiveActivitiesResponse, rhs: Afcon_GetActiveLiveActivitiesResponse) -> Bool {
    if lhs.activities != rhs.activities {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_LiveActivityInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LiveActivityInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}activity_uuid\0\u{3}fixture_id\0\u{3}activity_id\0\u{3}update_frequency\0\u{3}started_at\0\u{3}expires_at\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.activityUuid) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.fixtureID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.activityID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.updateFrequency) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._startedAt) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._expiresAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.activityUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.activityUuid, fieldNumber: 1)
    }
    if self.fixtureID != 0 {
      try visitor.visitSingularInt32Field(value: self.fixtureID, fieldNumber: 2)
    }
    if !self.activityID.isEmpty {
      try visitor.visitSingularStringField(value: self.activityID, fieldNumber: 3)
    }
    if !self.updateFrequency.isEmpty {
      try visitor.visitSingularStringField(value: self.updateFrequency, fieldNumber: 4)
    }
    try { if let v = self._startedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._expiresAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_LiveActivityInfo, rhs: Afcon_LiveActivityInfo) -> Bool {
    if lhs.activityUuid != rhs.activityUuid {return false}
    if lhs.fixtureID != rhs.fixtureID {return false}
    if lhs.activityID != rhs.activityID {return false}
    if lhs.updateFrequency != rhs.updateFrequency {return false}
    if lhs._startedAt != rhs._startedAt {return false}
    if lhs._expiresAt != rhs._expiresAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Afcon_LiveActivityContentState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LiveActivityContentState"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}fixture_id\0\u{3}home_team\0\u{3}away_team\0\u{3}home_score\0\u{3}away_score\0\u{1}status\0\u{1}elapsed\0\u{3}last_event\0\u{3}updated_at\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.fixtureID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.homeTeam) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.awayTeam) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.homeScore) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.awayScore) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.status) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.elapsed) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.lastEvent) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.fixtureID != 0 {
      try visitor.visitSingularInt32Field(value: self.fixtureID, fieldNumber: 1)
    }
    if !self.homeTeam.isEmpty {
      try visitor.visitSingularStringField(value: self.homeTeam, fieldNumber: 2)
    }
    if !self.awayTeam.isEmpty {
      try visitor.visitSingularStringField(value: self.awayTeam, fieldNumber: 3)
    }
    if self.homeScore != 0 {
      try visitor.visitSingularInt32Field(value: self.homeScore, fieldNumber: 4)
    }
    if self.awayScore != 0 {
      try visitor.visitSingularInt32Field(value: self.awayScore, fieldNumber: 5)
    }
    if !self.status.isEmpty {
      try visitor.visitSingularStringField(value: self.status, fieldNumber: 6)
    }
    if self.elapsed != 0 {
      try visitor.visitSingularInt32Field(value: self.elapsed, fieldNumber: 7)
    }
    if !self.lastEvent.isEmpty {
      try visitor.visitSingularStringField(value: self.lastEvent, fieldNumber: 8)
    }
    try { if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Afcon_LiveActivityContentState, rhs: Afcon_LiveActivityContentState) -> Bool {
    if lhs.fixtureID != rhs.fixtureID {return false}
    if lhs.homeTeam != rhs.homeTeam {return false}
    if lhs.awayTeam != rhs.awayTeam {return false}
    if lhs.homeScore != rhs.homeScore {return false}
    if lhs.awayScore != rhs.awayScore {return false}
    if lhs.status != rhs.status {return false}
    if lhs.elapsed != rhs.elapsed {return false}
    if lhs.lastEvent != rhs.lastEvent {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
